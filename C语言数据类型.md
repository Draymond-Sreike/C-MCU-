# C语言数据类型

- 51单片机的int占16位

- STM32的int占32位

- typedef是用来给数据类型重命名的

    - 可以给新的名字再重新又起一个名字，例如下面

        > ​	<img src="D:\大学\单片机学习\C语言数据类型\C-MCU-\image-20230127181216531-167481659277412.png" alt="image-20230127181216531" style="zoom:50%;" />
        >
        > ​	<img src="D:\大学\单片机学习\C语言数据类型\C-MCU-\image-20230127181216531.png" alt="image-20230127181216531" style="zoom:50%;" />

- define语句的最后不用分号，typedef语句的最后需要分号

## 结构体

### 定义

> ![image-20230127181907655](D:\大学\单片机学习\C语言数据类型\C-MCU-\image-20230127181907655-167489086157315.png)

### 使用

> ​	<img src="D:\大学\单片机学习\C语言数据类型\C-MCU-\image-20230127182021332-167489087137417.png" alt="image-20230127182021332" style="zoom:50%;" />

### 搭配使用typedef

> ​	<img src="D:\大学\单片机学习\C语言数据类型\C-MCU-\image-20230127182134880-167489088216019.png" alt="image-20230127182134880" style="zoom:50%;" />

### 结构体指针索引结构体成员

> ![image-20230127182318011](D:\大学\单片机学习\C语言数据类型\C-MCU-\image-20230127182318011-167489089364621.png)

## 枚举类型

此部分讲解见视频 [37：00~视频结束](https://www.bilibili.com/video/BV1th411z7sn/?p=7&spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=b8a7d9f6d396acb27e811371a96d6e9a)

> ![image-20230127183007364](D:\大学\单片机学习\C语言数据类型\C-MCU-\image-20230127183007364-167489090218323.png)

- 枚举与结构体差不多，也是一种数据类型

### 定义

> ![image-20230127183007364](D:\大学\单片机学习\C语言数据类型\C-MCU-\image-20230127183007364-167489090842925.png)

这样写就可以限制week这个**变量**的取值范围，只能取花括号里面的值（可以是MONDAT等字符串，也可以是这些字符串的对应值；如果赋其他的非括号内的值编译器就会报警告）

另外如果枚举类型中赋值定义是按顺序累加的，如上例中的“1、2、3”，那么后面的2、3就可以省略，编译器会自动默认为我们给这些赋值赋2和3

### typedef更改枚举类型名

> ​	<img src="D:\大学\单片机学习\C语言数据类型\C-MCU-\image-20230127183931845-167489092919627.png" alt="image-20230127183931845" style="zoom:50%;" />

### 枚举变量使用

> ​	<img src="D:\大学\单片机学习\C语言数据类型\C-MCU-\image-20230127184009315-167489093847029.png" alt="image-20230127184009315" style="zoom:50%;" />

此时的枚举变量week正常情况下就需要赋值花括号中的值，如果像上图中一样赋值8，正常情况下编译器就会报警告。

而在keil中如下例子

> ![image-20230127184318870](D:\大学\单片机学习\C语言数据类型\C-MCU-\image-20230127184318870.png)

> ![image-20230127184327395](D:\大学\单片机学习\C语言数据类型\C-MCU-\image-20230127184327395-167489096451332.png)

虽然枚举变量a的值中可以赋DISABLE，这个DISABLE对应的值也是0，但是在变量赋值时赋0却也会报警告，要解决这个报警告需要将0进行强制类型转换，才不会报警告，如下：

> ​	<img src="D:\大学\单片机学习\C语言数据类型\C-MCU-\image-20230127184538352-167489096978534.png" alt="image-20230127184538352" style="zoom:50%;" />

### 枚举值并非只能赋值给对应的枚举变量

> <img src="D:\大学\单片机学习\C语言数据类型\C-MCU-\image-20230127184538352-167489097833036.png" alt="image-20230127184538352" style="zoom:50%;" />

我们可以把FunctionalState枚举类型的枚举值ENABLE赋值给int类型变量a。

这就是枚举类型的**第二个用途：（相当于）一个宏定义的集合**。

# 指针

计算机存储绝大部分采用的是小端存储：

> ![image-20230128122347822](D:\大学\单片机学习\C语言数据类型\C-MCU-\image-20230128122347822.png)

并且这个小端存储是对一个字节作为单位而言。

## 注意`int* p,p1`

> ![image-20230128130908644](D:\大学\单片机学习\C语言数据类型\C-MCU-\image-20230128130908644.png)

这种情况下并不是定义两个int*的变量p和p1，而是p是int\*，而p1是int。这个内容的小讲解见视频 [18：00~20：00处](https://www.bilibili.com/video/BV1Mb4y1X7dz/?spm_id_from=333.999.0.0&vd_source=b8a7d9f6d396acb27e811371a96d6e9a)

## 数组与指针（数组名等价于指针）

> <img src="D:\大学\单片机学习\C语言数据类型\C-MCU-\image-20230129212544891.png" alt="image-20230129212544891" style="zoom:50%;" />

> <img src="D:\大学\单片机学习\C语言数据类型\C-MCU-\image-20230129212520734.png" alt="image-20230129212520734" style="zoom:50%;" />

## 使用指针的注意事项

> ![image-20230129213013184](D:\大学\单片机学习\C语言数据类型\C-MCU-\image-20230129213013184.png)

# .h文件用来可供外部调用的函数

> <img src="D:\大学\单片机学习\C语言数据类型\C-MCU-\image-20230128132036330.png" alt="image-20230128132036330" style="zoom:50%;" />

## const修饰指针形参可以防止指针所指向的内容被更改

> <img src="D:\大学\单片机学习\C语言数据类型\C-MCU-\image-20230130131638652.png" alt="image-20230130131638652" style="zoom: 50%;" />

此时const放在了定义时的*array之前，保证了\*array解引用时，array的所指向的内容不可被更改；

如果把const放在定义时*之后，array之前，则是array的本身不可被更改，但array所指向的内容可以被更改。

即相当于const修饰就使得数据变成了**只读而不可被修改**的状态。可以用于保护我们所传递的地址/指针所指向的内容的安全。

关于const这部分内容的讲解在我的某篇Cpp提到过。



**.h文件用来对模块外部声明：这个函数是可以被外部调用的函数。**